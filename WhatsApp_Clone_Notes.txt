--------- WHATSAPP_CLONE ---------

1. Dependencies
  -> client
    - "next":
    - "react": 
    - "react-dom": 
    - "postcss": 
    - "tailwindcss": 
    - "autoprefixer": 
    - "axios": for api calling
    - "emoji-picker-react": for emojis
    - "firebase": for auth
    - "react-icons": for icons
    - "react-image-file-resizer": for resizig the images
    - "socket.io-client": for client side sockets
    - "wavesurfer.js": for audio wave forms
    - "zego-express-engine-webrtc": for video and audio calling

  -> server
    - "@prisma/client": for database management
    - "cors": for handling cross origin requests
    - "crypto": for token genration
    - "dotenv": for envionment variable
    - "express": for apis
    - "multer": for handling files
    - "nodemon": for starting the server
    - "prisma": 
    - "socket.io": for server side sockets
  
2. Setup Firebase auth
  -> setup firebaseConfig and export firebaseAuth (utils/FirebaseConfig.js)
  
3. Setup Prisma (In Server Folder)
  -> npx prisma init
  -> in .env
    - DATABASE_URL="mongodb://localhost:27017/WhatsAppClone"
  -> in prisma/schema.prisma
    - Setup DataBase
      datasource db {
        provider = "mongodb"
        url      = env("DATABASE_URL")
      }
    - Setup Models
      model User {
        Id Int @id @map("_id")
        email String @unique
      }
  -> npx prisma generate
  -> npx prisma db push 
  -> npx prisma studio 

  -> To use prisma create a prisma client (utils/prismaClient.js)
      import { PrismaClient } from "@prisma/client";

      let prismaInstance = null;

      const getPrismaInstance = () => {
        if (!prismaInstance) {
          prismaInstance = new PrismaClient();
        }
        return prismaInstance;
      };

4. Setup Node Server (In Server Folder)
  -> create APIs

5. Login with Google
    const provider = new GoogleAuthProvider();
    const { user } = await signInWithPopup(firebaseAuth, provider);

6. Setup Redux store

7. Creating Conext Menu (components/common/ContextMenu.jsx)

8. React Portal (components/common/PhotoPicker.jsx)
  -> by default react renders components inside root (in NEXT renders inside _next)
  -> using portals we tell NEXT to render the components inside custom div
    
9. Created take photo, choose from library & upload photo features (avatar.js, onboarding/page.jsx)  

10. built "create-user" api (server/controllers/AuthController.js)  

11. on route changes checking in client app if user is still loggged in using firebase auth:
       onAuthStateChanged(firebaseAuth, async (currentUser) => {
          if (!currentUser) {
            setRedirectLogin(true);
          }
          if (!userInfo && currentUser?.email) {
            const { data } = await axios.post(CHECK_USER_ROUTE, {
              email: currentUser?.email,
            });
            if (data.status && data.data) {
              const { id, email, name, about, profilePicture } = data.data;
              dispatch(setNewUser(false));
              dispatch(
                setUserInfo({
                  id,
                  email,
                  name,
                  status: about,
                  profilePicture,
                })
              );
            } else {
              dispatch(setUserInfo(null));
              dispatch(setNewUser(false));
              router.push("/login");
            }
          }
        });

12. built "get-contacts" api (server/controllers/AuthController.js) and implemented in client (components/Chatlist/ContactList.jsx)
    -> Api: merged all the contacts in groups having same intial lettter.
    -> Client: on page load fetched all contact groups in the form of an object and mapped that object to render all contacts.
        Object.entries(allContacts).map(([intialLetter, userList]) => {
          return (
            <div key={Date.now() + intialLetter}>
              ... other_stuff(see components/Chatlist/ContactList.jsx)
            </div>
          );
        })

12. sockets
    -> server/index.js
      - make a global map to maintain sockets and users. Will maintain online and offline status of the users
      global.onlineUsers = new Map();
    -> server/controllers/MessageController.js
      - controller for addMessage
       const getUser = onlineUsers.get(to); // checks if sender is online
    -> Chat/MessageBar.jsx in client
      - send message using ADD_MESSAGE Api
      






















































































  